//
//  PayConfirmInteractor.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-04-28.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol PayConfirmBusinessLogic {
  func refresh(request: PayConfirm.Refresh.Request)
  func sendPayment(request: PayConfirm.SendPayment.Request)
}


protocol PayConfirmDataStore {
  var address: String? { get set }
  var amount: Bitcoin? { get set }
  var description: String? { get set }
  var fee: Bitcoin? { get set }
  var paymentType: BitcoinPaymentType? { get set }
  var confSpeed: OnChainConfirmSpeed? { get set }
}


class PayConfirmInteractor: PayConfirmBusinessLogic, PayConfirmDataStore {
  
  var presenter: PayConfirmPresentationLogic?
  
  // MARK: Data Store
  var address: String?
  var amount: Bitcoin?
  var description: String?
  var fee: Bitcoin?
  var paymentType: BitcoinPaymentType?
  var confSpeed: OnChainConfirmSpeed?
  
  // MARK: Refresh
  
  func refresh(request: PayConfirm.Refresh.Request) {
    guard let address = address, let amount = amount, let description = description, let paymentType = paymentType else {
      SLLog.fatal("1 or more entry in PayConfirmDataStore is nil")
    }

    // Calculate:
    var totalAmt = amount
    
    if let fee = fee {
      totalAmt = Bitcoin(amount + fee)
    }
    
    let response = PayConfirm.Refresh.Response(amount: amount,
                                               address: address,
                                               description: description,
                                               fee: fee,
                                               paymentType: paymentType,
                                               confSpeed: confSpeed,
                                               fiatAmount: Money<USD>("0.0")!,
                                               fiatFee: Money<USD>("0.0")!,
                                               totalAmount: totalAmt,
                                               fiatTotalAmt: Money<USD>("0.0")!)
    presenter?.presentRefresh(response: response)
  }
  
  
  // MARK: Send Payment
  
  func sendPayment(request: PayConfirm.SendPayment.Request) {
    
    // Try to send payment according to payment type
    guard var address = address, let amount = amount, let paymentType = paymentType else {
      SLLog.fatal("1 or more entry in PayConfirmDataStore is nil")
    }
    
    switch paymentType {
    case .lightning:
      // For now, we are only doing Pay Req for Lightning Payments
      
      // Note sometimes people have werid prefixes, drop it before proceeding
      address = address.lowercased()
      if address.hasPrefix("lightning:") {
        address = String(address.dropFirst("lightning:".count))
      }
      
      LNServices.sendPaymentSync(payReq: address) { (responder) in
        do {
          let payRsp = try responder()
          
          if payRsp.payError.isEmpty {
            // TODO: Should really display a confirmation screen on what the final transaction looked like
            SLLog.info("Payment Sent! Route used - \(payRsp.payRoute)")
            let response = PayConfirm.SendPayment.Response(result: Result.success(()))
            self.presenter?.presentSendPayment(response: response)
            
          } else {
            SLLog.warning("Payment Error - \(payRsp.payError)")
            let error = PayConfirm.SendPayment.Error.lnPayRspErr(payRsp.payError)
            let response = PayConfirm.SendPayment.Response(result: Result.failure(error))
            self.presenter?.presentSendPayment(response: response)
          }

        } catch {
          let response = PayConfirm.SendPayment.Response(result: Result.failure(error))
          self.presenter?.presentSendPayment(response: response)
        }
      }
      
    case .onChain:
      LNServices.sendCoins(address: address,
                           amount: amount.integerInSatoshis) { (responder) in
        do {
          let txid = try responder()
          SLLog.info("Coins Sent! TXID - \(txid)")
          
          let response = PayConfirm.SendPayment.Response(result: Result.success(()))
          self.presenter?.presentSendPayment(response: response)
        } catch {
          let response = PayConfirm.SendPayment.Response(result: Result.failure(error))
          self.presenter?.presentSendPayment(response: response)
        }
      }
    }
  }
}
