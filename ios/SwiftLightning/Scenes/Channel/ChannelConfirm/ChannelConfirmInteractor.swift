//
//  ChannelConfirmInteractor.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-04-25.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ChannelConfirmBusinessLogic {
  func refreshAll(request: ChannelConfirm.RefreshAll.Request)
  func openChannel(request: ChannelConfirm.OpenChannel.Request)
}


protocol ChannelConfirmDataStore {
  var nodePubKey: String? { get set }
  var nodeIP: String? { get set }
  var nodePort: Int? { get set }
  var fundingAmt: Bitcoin? { get set }
  var initPayAmt: Bitcoin? { get set }
  var confSpeed: OnChainConfirmSpeed? { get set }
}


class ChannelConfirmInteractor: ChannelConfirmBusinessLogic, ChannelConfirmDataStore {
  
  var presenter: ChannelConfirmPresentationLogic?
  
  // MARK: Data Store
  
  var nodePubKey: String?
  var nodeIP: String?
  var nodePort: Int?
  var fundingAmt: Bitcoin?
  var initPayAmt: Bitcoin?
  var confSpeed: OnChainConfirmSpeed?
  
  
  // MARK: Refresh Channel Confirmation

  func refreshAll(request: ChannelConfirm.RefreshAll.Request) {
    
    guard let nodePubKey = nodePubKey, let nodeIP = nodeIP, let nodePort = nodePort,
      let fundingAmt = fundingAmt, let initPayAmt = initPayAmt, let confSpeed = confSpeed else {
      SLLog.fatal("1 or more entry in ChannelConfirmDataStore is nil")
    }
    
    // Calculate:
    
    // Calculate Can Pay Amt = Funding Amt - Init Payment - Fee
    let canPayAmt = Bitcoin(fundingAmt - initPayAmt)  // TODO: minus Fees
    
    let response = ChannelConfirm.RefreshAll.Response<USD>(nodePubKey: nodePubKey,
                                                           nodeIP: nodeIP,
                                                           nodePort: nodePort,
                                                           fundingAmt: fundingAmt,
                                                           initPayAmt: initPayAmt,
                                                           confSpeed: confSpeed,
                                                           fiatFundingAmt: Money<USD>("0.0")!,
                                                           fiatInitPayAmt: Money<USD>("0.0")!,
                                                           canPayAmt: canPayAmt,
                                                           canRcvAmt: initPayAmt,
                                                           fiatCanPayAmt: Money<USD>("0.0")!,
                                                           fiatCanRcvAmt: Money<USD>("0.0")!,
                                                           feeAmt: Bitcoin("0.0")!,
                                                           fiatFeeAmt: Money<USD>("0.0")!)
    presenter?.presentRefreshAll(response: response)
  }
  
  
  // MARK: Open Channel
  
  func openChannel(request: ChannelConfirm.OpenChannel.Request) {

    guard let nodePubKeyString = nodePubKey, let nodeIP = nodeIP, let nodePort = nodePort,
      let fundingAmt = fundingAmt, let initPayAmt = initPayAmt else {
        SLLog.fatal("1 or more entry in ChannelConfirmDataStore is nil")
    }

    guard let nodePubKeyData = Data(hexString: nodePubKeyString) else {
      SLLog.fatal("Node Pub Key should have been validated ahead of time")
    }

    LNServices.connectPeer(pubKey: nodePubKeyString, hostAddr: nodeIP, hostPort: nodePort) { (responder) in
      do {
        try responder()
        
        // This is the actual request that opens the channel
        LNServices.openChannel(nodePubKey: nodePubKeyData,
                               localFundingAmt: fundingAmt.integerInSatoshis,
                               pushSat: initPayAmt.integerInSatoshis,
                               targetConf: LNConstants.defaultChannelConfirmation,
                               streaming: self.openChannelStreaming,
                               completion: self.openChannelCompletion)
        
      } catch {
        let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(error))
        self.presenter?.presentOpenChannel(response: response)
      }
    }
  }


  private func openChannelStreaming(callHandle: () throws -> (Lnrpc_LightningOpenChannelCall)) {
    do {
      /* call */ _ = try callHandle()
      // TODO: Pass to Stream Handler module for receive handling

      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.success(()))
      presenter?.presentOpenChannel(response: response)
    } catch {
      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(error))
      presenter?.presentOpenChannel(response: response)
    }
  }
  
  
  private func openChannelCompletion(responder: () throws -> ()) {
    do {
      try responder()
      // TODO: Do direct trigger into Event Center
    } catch {
      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(error))
      presenter?.presentOpenChannel(response: response)
      // TODO: Do direct trigger into Event Cetner
    }
  }
}
