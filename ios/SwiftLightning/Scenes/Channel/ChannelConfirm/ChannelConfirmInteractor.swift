//
//  ChannelConfirmInteractor.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-04-25.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ChannelConfirmBusinessLogic {
  func refresh(request: ChannelConfirm.Refresh.Request)
  func openChannel(request: ChannelConfirm.OpenChannel.Request)
}


protocol ChannelConfirmDataStore {
  var nodePubKey: String? { get set }
  var nodeIP: String? { get set }
  var nodePort: Int? { get set }
  var fundingAmt: Bitcoin? { get set }
  var initPayAmt: Bitcoin? { get set }
  var confSpeed: OnChainConfirmSpeed? { get set }
}


class ChannelConfirmInteractor: ChannelConfirmBusinessLogic, ChannelConfirmDataStore {
  
  var presenter: ChannelConfirmPresentationLogic?
  
  // MARK: Data Store
  
  var nodePubKey: String?
  var nodeIP: String?
  var nodePort: Int?
  var fundingAmt: Bitcoin?
  var initPayAmt: Bitcoin?
  var confSpeed: OnChainConfirmSpeed?
  
  
  // MARK: Refresh Channel Confirmation

  func refresh(request: ChannelConfirm.Refresh.Request) {
    
    guard let nodePubKey = nodePubKey, let nodeIP = nodeIP, let nodePort = nodePort,
      let fundingAmt = fundingAmt, let initPayAmt = initPayAmt, let confSpeed = confSpeed else {
      SLLog.fatal("1 or more entry in ChannelConfirmDataStore is nil")
    }
    
    // Calculate:
    
    // Calculate Can Pay Amt = Funding Amt - Init Payment - Fee
    let canPayAmt = Bitcoin(fundingAmt - initPayAmt)  // TODO: minus Fees
    
    let response = ChannelConfirm.Refresh.Response<USD>(nodePubKey: nodePubKey,
                                                        nodeIP: nodeIP,
                                                        nodePort: nodePort,
                                                        fundingAmt: fundingAmt,
                                                        initPayAmt: initPayAmt,
                                                        confSpeed: confSpeed,
                                                        fiatFundingAmt: Money<USD>("0.0")!,
                                                        fiatInitPayAmt: Money<USD>("0.0")!,
                                                        canPayAmt: canPayAmt,
                                                        canRcvAmt: initPayAmt,
                                                        fiatCanPayAmt: Money<USD>("0.0")!,
                                                        fiatCanRcvAmt: Money<USD>("0.0")!,
                                                        feeAmt: Bitcoin("0.0")!,
                                                        fiatFeeAmt: Money<USD>("0.0")!)
    presenter?.presentRefresh(response: response)
  }
  
  
  // MARK: Open Channel
  
  func openChannel(request: ChannelConfirm.OpenChannel.Request) {
    guard let nodePubKeyString = nodePubKey, let nodeIP = nodeIP, let nodePort = nodePort,
      fundingAmt != nil, initPayAmt != nil else {
        SLLog.fatal("1 or more entry in ChannelConfirmDataStore is nil")
    }

    guard Data(hexString: nodePubKeyString) != nil else {
      SLLog.fatal("Node Pub Key should have been validated ahead of time")
    }

    LNServices.connectPeer(pubKey: nodePubKeyString, hostAddr: nodeIP, hostPort: nodePort) { (responder) in
      do {
        try responder()
        self.checkPeerConnect(pubKey: nodePubKeyString)
        
      } catch {
        let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(error))
        self.presenter?.presentOpenChannel(response: response)
      }
    }
  }

  
  private func checkPeerConnect(pubKey: String) {
    guard let nodePubKeyString = nodePubKey, let fundingAmt = fundingAmt, let initPayAmt = initPayAmt else {
      SLLog.fatal("1 or more entry in ChannelConfirmDataStore is nil")
    }
    
    guard let nodePubKeyData = Data(hexString: nodePubKeyString) else {
      SLLog.fatal("Node Pub Key should have been validated ahead of time")
    }
    
    let retry = SLRetry()
    let task = { () -> () in
      
      LNServices.listPeers() { (responder) in
        do {
          let peers = try responder()
          if peers.contains(where: { $0.pubKey == pubKey }) {
            
            // This is the actual request that opens the channel
            LNServices.openChannel(nodePubKey: nodePubKeyData,
                                   localFundingAmt: fundingAmt.integerInSatoshis,
                                   pushSat: initPayAmt.integerInSatoshis,
                                   targetConf: LNConstants.defaultChannelConfirmation,
                                   completion: self.openChannelCompletion)
          } else {
            retry.attempt(error: ChannelConfirm.OpenChannel.Error.peerNotConnected)
          }
        } catch {
          let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(error))
          self.presenter?.presentOpenChannel(response: response)
        }
      }
    }
    let fail = { (failError: Error) -> () in
      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(failError))
      self.presenter?.presentOpenChannel(response: response)
    }
    
    retry.start("LN Find Peer",
                withCountOf: ChannelConfirm.OpenChannel.Constants.lnFindPeerRetry,
                withDelayOf: ChannelConfirm.OpenChannel.Constants.lnFindPeerDelay,
                taskBlock: task, failBlock: fail)
  }
  
  
//  private func openChannelStreaming(callHandle: () throws -> (Lnrpc_LightningOpenChannelCall)) {
//    do {
//      let _ = try callHandle()
//
//      // TODO: Pass to Stream Handler module for receive handling after the first stream
//
//      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.success(()))
//      presenter?.presentOpenChannel(response: response)
//    } catch {
//      // Counting on failures to come thru the Completion path instead of the Streaming path
////      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(error))
////      presenter?.presentOpenChannel(response: response)
//    }
//  }
  
  
  private func openChannelCompletion(responder: () throws -> ()) {
    do {
      try responder()
      // TODO: Do direct trigger into Event Center
      
      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.success(()))
      presenter?.presentOpenChannel(response: response)
    } catch {
      
      // This is the nay path if the Open Channel Scene still exists
      let response = ChannelConfirm.OpenChannel.Response(result: Result<Void>.failure(error))
      presenter?.presentOpenChannel(response: response)
      
      // If the Scene dun exist, route to Event Center instead
      // TODO: Do direct trigger into Event Cetner
    }
  }
}
