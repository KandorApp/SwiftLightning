//
//  CameraMainViewController.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-05-02.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import AVFoundation


protocol CameraMainDisplayLogic: class {
  func displayUpdate(viewModel: CameraMain.Update.ViewModel)
  func displayUpdateError(viewModel: CameraMain.Update.ErrorVM)
}


protocol CameraReturnDelegate: class {
  func qrCodeScanned(address: String)
}


class CameraMainViewController: SLViewController, CameraMainDisplayLogic {
  var interactor: (CameraMainBusinessLogic & AVCaptureMetadataOutputObjectsDelegate)?
  var router: (NSObjectProtocol & CameraMainRoutingLogic & CameraMainDataPassing)?
  var delegate: CameraReturnDelegate?
  
  
  // MARK: IBOutlet
  
  @IBOutlet weak var cameraView: UIView!
  @IBOutlet weak var scanFrameImageView: UIImageView!
  @IBOutlet weak var qrDialogView: UIView!
  @IBOutlet weak var qrDialogLabel: UILabel!
  @IBOutlet weak var toolbarHeightConstraint: NSLayoutConstraint!
  
  
  // MARK: Object lifecycle
  
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }
  
  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }
  
  
  // MARK: Setup
  
  private func setup() {
    let viewController = self
    let interactor = CameraMainInteractor()
    let presenter = CameraMainPresenter()
    let router = CameraMainRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }

  
  // MARK: View lifecycle
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    startQRCaptureSession()
    configAppearance()
  }
  
  
  // MARK: Appearance Configurations
  
  private func configAppearance() {
    let navBarHeight = (self.navigationController?.navigationBar.frame.height ?? 0.0)
    let topBarHeight = UIApplication.shared.statusBarFrame.size.height
    
    if navBarHeight != topBarHeight {
      toolbarHeightConstraint.constant = topBarHeight + navBarHeight
    } else {
      toolbarHeightConstraint.constant = navBarHeight
    }
    
    self.navigationItem.hidesBackButton = true
    
    qrDialogView.layer.cornerRadius = SLDesign.Constants.defaultCornerRadius
    qrDialogView.clipsToBounds = true
    
    let request = CameraMain.Update.Request()
    interactor?.update(request: request)
  }
  
  
  // MARK: Update Camera State
  
  func displayUpdate(viewModel: CameraMain.Update.ViewModel) {
    DispatchQueue.main.async {
      self.qrDialogLabel.text = viewModel.labelText
      self.scanFrameImageView.tintColor = viewModel.scanFrameColor
      
      if let address = viewModel.validAddress {
        self.delegate?.qrCodeScanned(address: address)
        self.router?.routeToPrevious()
        self.delegate = nil
        self.router = nil  // This is to debounce, otherwise displayUpdate can fire many times from QR scanning results
      }
    }
  }
  
  func displayUpdateError(viewModel: CameraMain.Update.ErrorVM) {
    let alertDialog = UIAlertController(title: viewModel.errTitle, message: viewModel.errLabel, preferredStyle: .alert).addAction(title: "OK", style: .default)
    DispatchQueue.main.async {
      self.present(alertDialog, animated: true, completion: nil)
    }
  }
  
  
  // MARK: QR Scanning
  
  var captureSession = AVCaptureSession()
  var videoPreviewLayer = AVCaptureVideoPreviewLayer()
  
  private func startQRCaptureSession() {
    // Get the back-facing camera for capturing videos
    let deviceDiscoverySession = AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera], mediaType: AVMediaType.video, position: .back)
    
    guard let captureDevice = deviceDiscoverySession.devices.first else {
      SLLog.warning("Failed to get the camera device")
      let viewModel = CameraMain.Update.ErrorVM(errTitle: "Camera Error", errLabel: "Failed to get the camera device")
      displayUpdateError(viewModel: viewModel)
      return
    }
    
    

    
    do {
      // Configure the Capture Device
      try captureDevice.lockForConfiguration()
      captureDevice.videoZoomFactor = 1.5  // Improves scanning of small QR codes
      captureDevice.setExposureTargetBias(-0.5, completionHandler: nil)  // Improve scanning in situations with glare
      captureDevice.unlockForConfiguration()
      
      // Get an instance of the AVCaptureDeviceInput class using the previous device object.
      let input = try AVCaptureDeviceInput(device: captureDevice)
      
      // Set input device & configure the capture session.
      captureSession.addInput(input)
      
      // Initialize a AVCaptureMetadataOutput object and set it as the output device to the capture session.
      let captureMetadataOutput = AVCaptureMetadataOutput()
      captureSession.addOutput(captureMetadataOutput)
      
      // Set delegate and use the default dispatch queue to execute the call back
      captureMetadataOutput.setMetadataObjectsDelegate(interactor!, queue: DispatchQueue.main)
      captureMetadataOutput.metadataObjectTypes = [AVMetadataObject.ObjectType.qr]
      
      // Initialize the video preview layer and add it as a sublayer to the viewPreview view's layer.
      videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
      videoPreviewLayer.videoGravity = AVLayerVideoGravity.resizeAspectFill
      videoPreviewLayer.frame = view.layer.bounds
      cameraView.layer.addSublayer(videoPreviewLayer)
      // Start video capture.
      captureSession.startRunning()
    } catch {
      // If any error occurs, simply print it out and don't continue any more.
      SLLog.warning("Getting capture device input error - \(error.localizedDescription)")
      return
    }
  }
  
  
  // MARK: Flash Toggle
  
  @IBAction func toggleFlash(_ sender: UIBarButtonItem) {
    guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {
      SLLog.assert("Cannot access AVCaputreDevice for video")
      return
    }
    
    if device.hasTorch {
      do {
        try device.lockForConfiguration()
        
        if device.torchMode == .on {
           device.torchMode = .off
        } else {
          device.torchMode = .on
        }
        device.unlockForConfiguration()
      } catch {
        SLLog.assert("Cannot lock AVCaptureDevice for configuration - \(error.localizedDescription)")
      }
    } else {
      SLLog.warning("Torch is not available")
    }
  }
  
  
  // MARK: Dismiss
  
  @IBAction func closeCrossTapped(_ sender: UIBarButtonItem) {
    router?.routeToPrevious()
  }
}
