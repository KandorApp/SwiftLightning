//
//  WalletMainInteractor.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-04-20.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol WalletMainBusinessLogic {
  func checkAutopilot(request: WalletMain.CheckAutopilot.Request)
  func updateBalances(request: WalletMain.UpdateBalances.Request)
  func updateChannels(request: WalletMain.UpdateChannels.Request)
  func updateTransactions(request: WalletMain.UpdateTransactions.Request)
  func updateChTx()
}

protocol WalletMainDataStore {
}


class WalletMainInteractor: WalletMainBusinessLogic, WalletMainDataStore {
  var presenter: WalletMainPresentationLogic?
  
  
  // MARK: Check Autopilot
  
  func checkAutopilot(request: WalletMain.CheckAutopilot.Request) {
    do {
      let config = try LNManager.getAutopilotSettings()
      let result = Result<Bool>.success(config.active)
      let response = WalletMain.CheckAutopilot.Response(result: result)
      presenter?.presentCheckAutopilot(response: response)
    } catch {
      let result = Result<Bool>.failure(error)
      let response = WalletMain.CheckAutopilot.Response(result: result)
      presenter?.presentCheckAutopilot(response: response)
    }
  }
  
  
  // MARK: Update Balances
  
  func updateBalances(request: WalletMain.UpdateBalances.Request) {
    LNServices.walletBalance() { (walletResponder) in
      do {
        let onChainBalance = try walletResponder()
        let onChainBitcoin = Bitcoin(inSatoshi: onChainBalance.total)
        
        LNServices.channelBalance() { (channelResponder) in
          do {
            let channelBalance = try channelResponder()
            let channelBitcoin = Bitcoin(inSatoshi: channelBalance.confirmed + channelBalance.pendingOpen)

            let response = WalletMain.UpdateBalances.Response(onChainBalance: onChainBitcoin, channelBalance: channelBitcoin)
            self.presenter?.presentUpdatedBalances(response: response)

          } catch {
            let response = WalletMain.UpdateBalances.Response(onChainBalance: onChainBitcoin, channelBalance: nil)
            self.presenter?.presentUpdatedBalances(response: response)
          }
        }

      } catch {
        let response = WalletMain.UpdateBalances.Response(onChainBalance: nil, channelBalance: nil)
        self.presenter?.presentUpdatedBalances(response: response)
      }
    }
  }
  
  
  // MARK: Update Transactions
  
  func updateTransactions(request: WalletMain.UpdateTransactions.Request) {
    
    LNServices.getTransactions { (btcResponder) in
      do {
        let btcTransactions = try btcResponder()
        
        LNServices.listPayments { (lnResponder) in
          do {
            let lnPayments = try lnResponder()
            let transactions = WalletMain.UpdateTransactions.Transactions(btcTransactions: btcTransactions,
                                                                          lnPayments: lnPayments)
            
            let result = Result<WalletMain.UpdateTransactions.Transactions>.success(transactions)
            let response = WalletMain.UpdateTransactions.Response(result: result)
            self.presenter?.presentUpdatedTransactions(response: response)
            
          } catch {
            let result = Result<WalletMain.UpdateTransactions.Transactions>.failure(error)
            let response = WalletMain.UpdateTransactions.Response(result: result)
            self.presenter?.presentUpdatedTransactions(response: response)
          }
        }
        
      } catch {
        let result = Result<WalletMain.UpdateTransactions.Transactions>.failure(error)
        let response = WalletMain.UpdateTransactions.Response(result: result)
        self.presenter?.presentUpdatedTransactions(response: response)
      }
    }
  }
  
  
  // MARK: Update Channels
  
  func updateChannels(request: WalletMain.UpdateChannels.Request) {
    // Try to reconnect any channels not already connected first
    LNManager.reconnectAllChannels()
    
    ChannelVM.getFromLN { (responder) in
      do {
        let channels = try responder()
        let result = Result<[ChannelVM]>.success(channels)
        let response = WalletMain.UpdateChannels.Response(result: result)
        self.presenter?.presentUpdatedChannels(response: response)
      }
      catch {
        let result = Result<[ChannelVM]>.failure(error)
        let response = WalletMain.UpdateChannels.Response(result: result)
        self.presenter?.presentUpdatedChannels(response: response)
      }
    }
  }
  
  
  // MARK: Update Channels & Transactions with no sort options
  
  func updateChTx() {
    // Try to reconnect any channels not already connected first
    LNManager.reconnectAllChannels()
    
    ChannelVM.getFromLN { (responder) in
      do {
        let channels = try responder()
        let result = Result<[ChannelVM]>.success(channels)
        let response = WalletMain.UpdateChannels.Response(result: result)
        self.presenter?.presentUpdatedChannels(response: response)
        
        self.updateTransactions(request: WalletMain.UpdateTransactions.Request())
      }
      catch {
        let result = Result<[ChannelVM]>.failure(error)
        let response = WalletMain.UpdateChannels.Response(result: result)
        self.presenter?.presentUpdatedChannels(response: response)
      }
    }
  }
}
