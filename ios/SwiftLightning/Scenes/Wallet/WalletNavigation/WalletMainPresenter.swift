//
//  WalletMainPresenter.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-04-20.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol WalletMainPresentationLogic {
  func presentUpdatedBalances(response: WalletMain.UpdateBalances.Response)
  func presentUpdatedChannels(response: WalletMain.UpdateChannels.Response)
  func presentUpdatedTransactions(response: WalletMain.UpdateTransactions.Response)
}


class WalletMainPresenter: WalletMainPresentationLogic {
  weak var viewController: WalletMainDisplayLogic?
  
  private var channelSem = DispatchSemaphore(value: 1)
  private var channelOpenTxIDs = Set<String>()
  private var channelCloseTxIDs = Set<String>()
  
  
  // MARK: Update Balances
  
  func presentUpdatedBalances(response: WalletMain.UpdateBalances.Response) {
    guard let onChainBalance = response.onChainBalance, let channelBalance = response.channelBalance else {
      let viewModel = WalletMain.UpdateBalances.ErrorVM(errTitle: "Balance Error",
                                                        errMsg: "Cannot get Wallet and Channel Balance. Consider restarting the app to recover")
      viewController?.displayBalancesError(viewModel: viewModel)
      return
    }
    
    let totalBalance = Bitcoin(onChainBalance + channelBalance)
    let totalString = "\(totalBalance.formattedInSatoshis())"
    let channelString = "\(channelBalance.formattedInSatoshis())"
    let viewModel = WalletMain.UpdateBalances.ViewModel(totalBalanceString: totalString,
                                                        channelBalanceString: channelString)
    viewController?.displayBalances(viewModel: viewModel)
  }
  
  
  // MARK: Update Transactions
  func presentUpdatedTransactions(response: WalletMain.UpdateTransactions.Response) {
    switch response.result {
    case .success(let result):
      
      typealias Transaction = WalletMain.UpdateTransactions.Transaction
      
      var transactions = [Transaction]()
      var statusText: String
      var statusColor: UIColor
      var dateText: String
      let dateFormatter = DateFormatter()
      dateFormatter.locale = Locale.current
      dateFormatter.setLocalizedDateFormatFromTemplate("MMM d, h:mm a")
      
      for btcTransaction in result.btcTransactions {
        guard btcTransaction.destAddresses.count > 0 else {
          SLLog.warning("No destination addresses in btcTransaction")
          continue
        }

        // Amounts & Fee
        let amount = Bitcoin(inSatoshi: btcTransaction.amount)
        let fee = Bitcoin(inSatoshi: btcTransaction.totalFees)
        
        // Determine date
        let date = Date(timeIntervalSince1970: TimeInterval(btcTransaction.timeStamp))
        
        if btcTransaction.amount < 0 {
          dateText = "Sent \(dateFormatter.string(from: date))"
        } else {
          dateText = "Rcvd \(dateFormatter.string(from: date))"
        }
        
        // The only thing that can affect the status label is # of confirmations?
        statusText = "\(btcTransaction.numConfirmations) confs"
        switch btcTransaction.numConfirmations {
        case 6...Int.max:
          statusText = "6+ confs"
          statusColor = UIColor.medAquamarine
        case 3..<6:
          statusColor = UIColor.medAquamarine
        case 2..<3:
          statusColor = UIColor.mediumTextGray
        case 1:
          statusText = "1 conf"
          statusColor = UIColor.mediumTextGray
        case 0:
          statusColor = UIColor.sandyOrange
        default:
          statusText = "Error"
          statusColor = UIColor.jellyBeanRed
        }
        
        // Add a note if Tx is associated with Channel Open/Closes
        var addressText = btcTransaction.destAddresses[0]
        
        channelSem.wait()
        if channelOpenTxIDs.contains(btcTransaction.txHash) {
          addressText = "Channel Open Tx - \(btcTransaction.destAddresses[0])"
        }
        
        if channelCloseTxIDs.contains(btcTransaction.txHash) {
          addressText = "Channel Close Tx - \(btcTransaction.destAddresses[0])"
        }
        channelSem.signal()
        
        let transaction = Transaction(date: date,
                                      paymentType: .onChain,
                                      address: addressText,
                                      txHash: btcTransaction.txHash,
                                      statusText: statusText,
                                      statusColor: statusColor,
                                      dateText: dateText,
                                      amountText: amount.formattedInSatoshis(),
                                      feeText: "fee: \(fee.formattedInSatoshis())")
        
        transactions.append(transaction)
      }
      
      for lnPayment in result.lnPayments {
        
        guard lnPayment.path.count > 0, let address = lnPayment.path.last else {
          SLLog.assert("0 paths in LN Payment")
          continue
        }
        
        // Amount & fee
        let amount = Bitcoin(inSatoshi: -lnPayment.value)  // Payment is always negative
        let fee = Bitcoin(inSatoshi: lnPayment.fee)
        
        // Determine date
        let date = Date(timeIntervalSince1970: TimeInterval(lnPayment.creationDate))
        dateText = "Sent \(dateFormatter.string(from: date))"
        
        // What status is there to report but hops?
        let hops = lnPayment.path.count - 1
        if hops == 1 {
          statusText = "\(hops) hop"
        } else {
          statusText = "\(hops) hops"
        }
        statusColor = UIColor.mediumTextGray
        
        let transaction = Transaction(date: date,
                                      paymentType: .lightning,
                                      address: address,
                                      txHash: lnPayment.paymentHash,
                                      statusText: statusText,
                                      statusColor: statusColor,
                                      dateText: dateText,
                                      amountText: amount.formattedInSatoshis(),
                                      feeText: "fee: \(fee.formattedInSatoshis())")
        
        transactions.append(transaction)
      }
      
      // TODO: Filter
      
      // Sort by status, then capacity, for now
      transactions.sort { $0.date > $1.date }
      
      let viewModel = WalletMain.UpdateTransactions.ViewModel(transactions: transactions)
      viewController?.updateTransactions(viewModel: viewModel)
      
    case .failure(let error):
      let viewModel = WalletMain.UpdateTransactions.ErrorVM(errTitle: "Transactions Error",
                                                            errMsg: error.localizedDescription)
      viewController?.displayTransactionsError(viewModel: viewModel)
    }
  }
  
  
  
  // MARK: Update Channels
  
  func presentUpdatedChannels(response: WalletMain.UpdateChannels.Response) {
    switch response.result {
    case .success(var channels):
      // TODO: Filter
      
      // Sort by status, then capacity, for now
      channels.sort {
        guard $0.state.rawValue != $1.state.rawValue else {
          return $0.capacity > $1.capacity
        }
        return $0.state.rawValue < $1.state.rawValue
      }
      
      // Track transactions that are Opens, Closes, etc
      channelSem.wait()
      channelOpenTxIDs.removeAll(keepingCapacity: true)
      channelCloseTxIDs.removeAll(keepingCapacity: true)
      
      for channel in channels {
        if let addlInfo = channel.addlInfo {
          switch addlInfo {
          case .pendingClose(let closeTxID):
            channelCloseTxIDs.insert(closeTxID)
          case .forceClose(_, let closeTxID):
            channelCloseTxIDs.insert(closeTxID)
          default:
            break
          }
        }
        
        let subStrings = channel.channelPoint.split(separator: ":")
        if subStrings.count > 0 {
          channelOpenTxIDs.insert(String(subStrings[0]))
        }
      }
      channelSem.signal()
        
      let viewModel = WalletMain.UpdateChannels.ViewModel(channels: channels)
      viewController?.updateChannels(viewModel: viewModel)
      
    case .failure(let error):
      let viewModel = WalletMain.UpdateChannels.ErrorVM(errTitle: "Channels Error",
                                                        errMsg: error.localizedDescription)
      viewController?.displayChannelsError(viewModel: viewModel)
    }
  }
}
