//
//  PasswordCreateInteractor.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-04-17.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol PasswordCreateBusinessLogic
{
  func validatePasswords(request: PasswordCreate.ValidatePasswords.Request)
  func seedWallet(request: PasswordCreate.SeedWallet.Request)
}

protocol PasswordCreateDataStore
{
  // var name: String { get set }
}

class PasswordCreateInteractor: PasswordCreateBusinessLogic, PasswordCreateDataStore
{
  var presenter: PasswordCreatePresentationLogic?
  var worker: PasswordCreateWorker?

  
  // MARK: Password Validation Logic. Worker not required?
  
  func validatePasswords(request: PasswordCreate.ValidatePasswords.Request) {
    let checkResult = checkPasswordAndConfirmation(password: request.passwordText, confirmation: request.confirmText)
    let response = PasswordCreate.ValidatePasswords.Response(passwordFieldStatus: checkResult.passwordStatus, confirmFieldStatus: checkResult.confirmStatus)
    presenter?.presentSceneUpdate(response: response)
  }
  
  private func checkPasswordAndConfirmation(password: String, confirmation: String) ->
    (passwordStatus: PasswordCreate.ValidatePasswords.ValidatePasswordStatusEnum, confirmStatus: PasswordCreate.ValidatePasswords.ValidateConfirmStatusEnum) {
      
    var passwordStatus: PasswordCreate.ValidatePasswords.ValidatePasswordStatusEnum
    
    if password.count < PasswordCreate.ValidatePasswords.Constants.minNumChar {
      passwordStatus = .needMoreCharacters
    }
    else if password.count > PasswordCreate.ValidatePasswords.Constants.maxNumChar {
      passwordStatus = .tooManyCharacters
    }
    else {
      passwordStatus = .passwordOk
    }
    
    var confirmStatus: PasswordCreate.ValidatePasswords.ValidateConfirmStatusEnum
    
    if confirmation.count == 0 || passwordStatus != .passwordOk {
      confirmStatus = .needsConfirmation
    } else if password != confirmation {
      confirmStatus = .passwordMismatch
    } else {
      confirmStatus = .confirmationOk
    }
    
    return (passwordStatus, confirmStatus)
  }
  
  
  // MARK: Seed Generation and Wallet Creation Logic
  
  private var passwordPlaintext: String?  // WARNING: Explicit clear just in case

  private func seedWalletResponse(error: Error?) {
    var result: Result<Void>
    
    if let error = error {
      result = .failure(error)
    } else {
      result = .success(())
    }
    
    let response = PasswordCreate.SeedWallet.Response(result: result)
    presenter?.presentSeedWalletResult(response: response)
  }
  
  func seedWallet(request: PasswordCreate.SeedWallet.Request) {
    let checkResult = checkPasswordAndConfirmation(password: request.passwordText, confirmation: request.confirmText)
    
    do {
      guard checkResult.passwordStatus == .passwordOk, checkResult.confirmStatus == .confirmationOk else {
        seedWalletResponse(error: PasswordCreate.SeedWalletError.PasswordConfirmFailed("Seed Wallet Passowrd Confirm Failed"))
        return
      }
      
      // Store the password locally for now. Otherwise it's really hard to manage.
      passwordPlaintext = request.passwordText
      
      try LNServices.generateSeed(completion: generateSeedCompletion)

    } catch {
      seedWalletResponse(error: error)
    }
  }
  
  private func generateSeedCompletion(result: () throws -> [String]) {
    defer { passwordPlaintext = nil }
    
    do {
      guard let password = passwordPlaintext else {
        SLLog.fatal("Generate seed completed but no plaintext password")
      }
      
      let cipherSeedMnemonics = try result()
      
      guard cipherSeedMnemonics.count == LNConstants.cipherSeedMnemonicWordCount else {
        seedWalletResponse(error: PasswordCreate.SeedWalletError.GenerateSeedInvalidMnemonics("Generate Seed returend invalid mnemonics"))
        return
      }
      
      try LNServices.createWallet(walletPassword: password,
                                  cipherSeedMnemonic: cipherSeedMnemonics,
                                  completion: createWalletCompletion)
    } catch {
      seedWalletResponse(error: error)
    }
  }
  
  private func createWalletCompletion(result: () throws -> ()) {
    
    do {
      try result()
      seedWalletResponse(error: nil)
    } catch {
      seedWalletResponse(error: error)
    }
  }
}
