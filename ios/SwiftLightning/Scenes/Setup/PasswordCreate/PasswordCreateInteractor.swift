//
//  PasswordCreateInteractor.swift
//  SwiftLightning
//
//  Created by Howard Lee on 2018-04-17.
//  Copyright (c) 2018 BiscottiGelato. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol PasswordCreateBusinessLogic
{
  func validatePasswords(request: PasswordCreate.ValidatePasswords.Request)
  func seedWallet(request: PasswordCreate.SeedWallet.Request)
}

protocol PasswordCreateDataStore
{
  // var name: String { get set }
}

class PasswordCreateInteractor: PasswordCreateBusinessLogic, PasswordCreateDataStore
{
  var presenter: PasswordCreatePresentationLogic?
  var worker: PasswordCreateWorker?

  
  // MARK: Password Validation Logic
  // TODO: Measure Password Strength for user
  
  func validatePasswords(request: PasswordCreate.ValidatePasswords.Request) {
    let checkResult = checkPasswordAndConfirmation(password: request.passwordText, confirmation: request.confirmText)
    let response = PasswordCreate.ValidatePasswords.Response(passwordFieldStatus: checkResult.passwordStatus, confirmFieldStatus: checkResult.confirmStatus)
    presenter?.presentSceneUpdate(response: response)
  }
  
  private func checkPasswordAndConfirmation(password: String, confirmation: String) ->
    (passwordStatus: PasswordCreate.ValidatePasswords.ValidatePasswordStatusEnum, confirmStatus: PasswordCreate.ValidatePasswords.ValidateConfirmStatusEnum) {
      
    var passwordStatus: PasswordCreate.ValidatePasswords.ValidatePasswordStatusEnum
    
    if password.count < PasswordCreate.ValidatePasswords.Constants.minNumChar {
      passwordStatus = .needMoreCharacters
    }
    else if password.count > PasswordCreate.ValidatePasswords.Constants.maxNumChar {
      passwordStatus = .tooManyCharacters
    }
    else {
      passwordStatus = .passwordOk
    }
    
    var confirmStatus: PasswordCreate.ValidatePasswords.ValidateConfirmStatusEnum
    
    if confirmation.count == 0 || passwordStatus != .passwordOk {
      confirmStatus = .needsConfirmation
    } else if password != confirmation {
      confirmStatus = .passwordMismatch
    } else {
      confirmStatus = .confirmationOk
    }
    
    return (passwordStatus, confirmStatus)
  }
  
  
  // MARK: Seed Generation and Wallet Creation Logic
  
  private var passwordPlaintext: String?  // WARNING: Explicit clear just in case

  private func seedWalletResponse(error: Error?) {
    var result: Result<Void>
    
    if let error = error {
      result = .failure(error)
    } else {
      result = .success(())
    }
    
    let response = PasswordCreate.SeedWallet.Response(result: result)
    presenter?.presentSeedWalletResult(response: response)
  }
  
  
  // Problem 1: Problem here is that if someone background/quits the app mid way, there's no way to see the Seed again
  // Either way, the app will have to store the Seed on disk somehow. For Option 1 temporarily, for Option 2 for the lifetime of the wallet
  // Option 1: User can see the seed whenever they want from Settings. This means the app needs to keep a copy of the seed outside of LND permanently
  // Option 2: App keeps the seed until the user confirms the seed. App will keep promtping user to confirm seed until that's done
  
  // Problem 2: We need a way to make the user confirm passwords again, for transactions and any system changes.
  // Question: Can LND unlock be a way to check the password, even after the wallet is unlocked?
  // Option 1: LND unlock works
  // Option 2: We need to hash the password and store it on encrypted on disk.
  // Option 3: We require the user to unlock the wallet everytime the app is booted out of memory. We use that opportunity to store the hashed password in memory. If the hashed password is booted out of memory, we assume the app will be booted out of memory also. Which means when the user use the app again, he/she will type in the password. We will store the hash of the correct password again for the lifetime the app is in memory again and use it to verify subsequent operations.
  
  func seedWallet(request: PasswordCreate.SeedWallet.Request) {
    let checkResult = checkPasswordAndConfirmation(password: request.passwordText, confirmation: request.confirmText)
    
    do {
      guard checkResult.passwordStatus == .passwordOk, checkResult.confirmStatus == .confirmationOk else {
        seedWalletResponse(error: PasswordCreate.SeedWalletError.PasswordConfirmFailed("Seed Wallet Passowrd Confirm Failed"))
        return
      }
      
      // Store the password locally for now. Otherwise it's really hard to manage.
      passwordPlaintext = request.passwordText
      
      try LNServices.generateSeed(completion: generateSeedCompletion)

    } catch {
      seedWalletResponse(error: error)
    }
  }
  
  private func generateSeedCompletion(result: () throws -> [String]) {
    do {
      defer { passwordPlaintext = nil }
      
      guard let password = passwordPlaintext else {
        SLLog.fatal("Generate seed completed but no plaintext password")
      }
      
      let cipherSeedMnemonic = try result()
      
      guard cipherSeedMnemonic.count == LNConstants.cipherSeedMnemonicWordCount else {
        seedWalletResponse(error: PasswordCreate.SeedWalletError.GenerateSeedInvalidMnemonic("Generate Seed returend invalid mnemonic"))
        return
      }
      
      LNManager.set(cipherSeedMnemonic: cipherSeedMnemonic) // Setting here, must clear on setup completion
      
      try LNServices.createWallet(walletPassword: password,
                                  cipherSeedMnemonic: cipherSeedMnemonic,
                                  completion: createWalletCompletion)
    } catch {
      passwordPlaintext = nil
      seedWalletResponse(error: error)
    }
  }
  
  private func createWalletCompletion(result: () throws -> ()) {
    do {
      try result()
      seedWalletResponse(error: nil)
    } catch {
      seedWalletResponse(error: error)
    }
  }
}
